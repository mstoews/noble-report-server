// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: kanban.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTask = `-- name: CreateTask :one
INSERT INTO kb_task (task_id, title, status, summary, type, priority, tags, estimate, assignee, rankid,
                     color, classname, dependencies, description, due_date, start_date)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16 )
RETURNING task_id, title, status, summary, type, priority, tags, estimate, assignee, rankid, color, classname, dependencies, description, due_date, start_date
`

type CreateTaskParams struct {
	TaskID       string      `json:"task_id"`
	Title        pgtype.Text `json:"title"`
	Status       pgtype.Text `json:"status"`
	Summary      pgtype.Text `json:"summary"`
	Type         pgtype.Text `json:"type"`
	Priority     pgtype.Text `json:"priority"`
	Tags         pgtype.Text `json:"tags"`
	Estimate     pgtype.Int4 `json:"estimate"`
	Assignee     pgtype.Text `json:"assignee"`
	Rankid       pgtype.Int4 `json:"rankid"`
	Color        pgtype.Text `json:"color"`
	Classname    pgtype.Text `json:"classname"`
	Dependencies pgtype.Text `json:"dependencies"`
	Description  pgtype.Text `json:"description"`
	DueDate      pgtype.Date `json:"due_date"`
	StartDate    pgtype.Date `json:"start_date"`
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (KbTask, error) {
	row := q.db.QueryRow(ctx, createTask,
		arg.TaskID,
		arg.Title,
		arg.Status,
		arg.Summary,
		arg.Type,
		arg.Priority,
		arg.Tags,
		arg.Estimate,
		arg.Assignee,
		arg.Rankid,
		arg.Color,
		arg.Classname,
		arg.Dependencies,
		arg.Description,
		arg.DueDate,
		arg.StartDate,
	)
	var i KbTask
	err := row.Scan(
		&i.TaskID,
		&i.Title,
		&i.Status,
		&i.Summary,
		&i.Type,
		&i.Priority,
		&i.Tags,
		&i.Estimate,
		&i.Assignee,
		&i.Rankid,
		&i.Color,
		&i.Classname,
		&i.Dependencies,
		&i.Description,
		&i.DueDate,
		&i.StartDate,
	)
	return i, err
}

const getTasks = `-- name: GetTasks :many
SELECT task_id, title, status, summary, type, priority, tags, estimate, assignee, rankid, color, classname, dependencies, description, due_date, start_date FROM kb_task WHERE task_id = $1 ORDER BY 1
`

func (q *Queries) GetTasks(ctx context.Context, taskID string) ([]KbTask, error) {
	rows, err := q.db.Query(ctx, getTasks, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []KbTask{}
	for rows.Next() {
		var i KbTask
		if err := rows.Scan(
			&i.TaskID,
			&i.Title,
			&i.Status,
			&i.Summary,
			&i.Type,
			&i.Priority,
			&i.Tags,
			&i.Estimate,
			&i.Assignee,
			&i.Rankid,
			&i.Color,
			&i.Classname,
			&i.Dependencies,
			&i.Description,
			&i.DueDate,
			&i.StartDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPriority = `-- name: ListPriority :many
SELECT priority, description, updatedte, updateusr FROM kb_priority ORDER BY 1
`

func (q *Queries) ListPriority(ctx context.Context) ([]KbPriority, error) {
	rows, err := q.db.Query(ctx, listPriority)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []KbPriority{}
	for rows.Next() {
		var i KbPriority
		if err := rows.Scan(
			&i.Priority,
			&i.Description,
			&i.Updatedte,
			&i.Updateusr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStatus = `-- name: ListStatus :many
SELECT status, description, updatedte, updateusr FROM kb_status ORDER BY 1
`

func (q *Queries) ListStatus(ctx context.Context) ([]KbStatus, error) {
	rows, err := q.db.Query(ctx, listStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []KbStatus{}
	for rows.Next() {
		var i KbStatus
		if err := rows.Scan(
			&i.Status,
			&i.Description,
			&i.Updatedte,
			&i.Updateusr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubTask = `-- name: ListSubTask :many
SELECT task_id, subid, "desc", status, summary, type, estimate FROM kb_subtask ORDER BY 1
`

func (q *Queries) ListSubTask(ctx context.Context) ([]KbSubtask, error) {
	rows, err := q.db.Query(ctx, listSubTask)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []KbSubtask{}
	for rows.Next() {
		var i KbSubtask
		if err := rows.Scan(
			&i.TaskID,
			&i.Subid,
			&i.Desc,
			&i.Status,
			&i.Summary,
			&i.Type,
			&i.Estimate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasks = `-- name: ListTasks :many
SELECT task_id, title, status, summary, type, priority, tags, estimate, assignee, rankid, color, classname, dependencies, description, due_date, start_date FROM kb_task ORDER BY 1
`

func (q *Queries) ListTasks(ctx context.Context) ([]KbTask, error) {
	rows, err := q.db.Query(ctx, listTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []KbTask{}
	for rows.Next() {
		var i KbTask
		if err := rows.Scan(
			&i.TaskID,
			&i.Title,
			&i.Status,
			&i.Summary,
			&i.Type,
			&i.Priority,
			&i.Tags,
			&i.Estimate,
			&i.Assignee,
			&i.Rankid,
			&i.Color,
			&i.Classname,
			&i.Dependencies,
			&i.Description,
			&i.DueDate,
			&i.StartDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeam = `-- name: ListTeam :many
SELECT team_member, first_name, last_name, location, title, updatedte, updateusr FROM kb_team ORDER BY 1
`

func (q *Queries) ListTeam(ctx context.Context) ([]KbTeam, error) {
	rows, err := q.db.Query(ctx, listTeam)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []KbTeam{}
	for rows.Next() {
		var i KbTeam
		if err := rows.Scan(
			&i.TeamMember,
			&i.FirstName,
			&i.LastName,
			&i.Location,
			&i.Title,
			&i.Updatedte,
			&i.Updateusr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listType = `-- name: ListType :many
SELECT type, description, updatedte, updateusr FROM kb_type ORDER BY 1
`

func (q *Queries) ListType(ctx context.Context) ([]KbType, error) {
	rows, err := q.db.Query(ctx, listType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []KbType{}
	for rows.Next() {
		var i KbType
		if err := rows.Scan(
			&i.Type,
			&i.Description,
			&i.Updatedte,
			&i.Updateusr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTask = `-- name: UpdateTask :one
UPDATE kb_task 
SET
    task_id = $1,
    title = $2,  
    status = $3, 
    summary = $4,  
    type = $5,  
    priority = $6,  
    tags = $7,  
    estimate = $8,  
    assignee = $9,  
    rankid = $10, 
    color = $11,  
    classname = $12,  
    dependencies = $13,  
    description = $14,  
    due_date = $15,  
    start_date = $16 
WHERE task_id = $1
RETURNING task_id, title, status, summary, type, priority, tags, estimate, assignee, rankid, color, classname, dependencies, description, due_date, start_date
`

type UpdateTaskParams struct {
	TaskID       string      `json:"task_id"`
	Title        pgtype.Text `json:"title"`
	Status       pgtype.Text `json:"status"`
	Summary      pgtype.Text `json:"summary"`
	Type         pgtype.Text `json:"type"`
	Priority     pgtype.Text `json:"priority"`
	Tags         pgtype.Text `json:"tags"`
	Estimate     pgtype.Int4 `json:"estimate"`
	Assignee     pgtype.Text `json:"assignee"`
	Rankid       pgtype.Int4 `json:"rankid"`
	Color        pgtype.Text `json:"color"`
	Classname    pgtype.Text `json:"classname"`
	Dependencies pgtype.Text `json:"dependencies"`
	Description  pgtype.Text `json:"description"`
	DueDate      pgtype.Date `json:"due_date"`
	StartDate    pgtype.Date `json:"start_date"`
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) (KbTask, error) {
	row := q.db.QueryRow(ctx, updateTask,
		arg.TaskID,
		arg.Title,
		arg.Status,
		arg.Summary,
		arg.Type,
		arg.Priority,
		arg.Tags,
		arg.Estimate,
		arg.Assignee,
		arg.Rankid,
		arg.Color,
		arg.Classname,
		arg.Dependencies,
		arg.Description,
		arg.DueDate,
		arg.StartDate,
	)
	var i KbTask
	err := row.Scan(
		&i.TaskID,
		&i.Title,
		&i.Status,
		&i.Summary,
		&i.Type,
		&i.Priority,
		&i.Tags,
		&i.Estimate,
		&i.Assignee,
		&i.Rankid,
		&i.Color,
		&i.Classname,
		&i.Dependencies,
		&i.Description,
		&i.DueDate,
		&i.StartDate,
	)
	return i, err
}
