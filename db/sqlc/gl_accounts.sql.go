// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: gl_accounts.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGLAccount = `-- name: CreateGLAccount :one
insert into gl_accounts (account, child, parent_account, type, sub_type, description, balance, comments, create_date,
                         create_user, update_date, update_user)
values (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12    
) RETURNING account, child, parent_account, type, sub_type, description, balance, comments, create_date, create_user, update_date, update_user
`

type CreateGLAccountParams struct {
	Account       int32          `json:"account"`
	Child         int32          `json:"child"`
	ParentAccount pgtype.Bool    `json:"parent_account"`
	Type          pgtype.Text    `json:"type"`
	SubType       pgtype.Text    `json:"sub_type"`
	Description   pgtype.Text    `json:"description"`
	Balance       pgtype.Numeric `json:"balance"`
	Comments      pgtype.Text    `json:"comments"`
	CreateDate    pgtype.Date    `json:"create_date"`
	CreateUser    pgtype.Text    `json:"create_user"`
	UpdateDate    pgtype.Date    `json:"update_date"`
	UpdateUser    pgtype.Text    `json:"update_user"`
}

func (q *Queries) CreateGLAccount(ctx context.Context, arg CreateGLAccountParams) (GlAccount, error) {
	row := q.db.QueryRow(ctx, createGLAccount,
		arg.Account,
		arg.Child,
		arg.ParentAccount,
		arg.Type,
		arg.SubType,
		arg.Description,
		arg.Balance,
		arg.Comments,
		arg.CreateDate,
		arg.CreateUser,
		arg.UpdateDate,
		arg.UpdateUser,
	)
	var i GlAccount
	err := row.Scan(
		&i.Account,
		&i.Child,
		&i.ParentAccount,
		&i.Type,
		&i.SubType,
		&i.Description,
		&i.Balance,
		&i.Comments,
		&i.CreateDate,
		&i.CreateUser,
		&i.UpdateDate,
		&i.UpdateUser,
	)
	return i, err
}

const getGLAccount = `-- name: GetGLAccount :one
SELECT account, child, parent_account, type, sub_type, description, balance, comments, create_date, create_user, update_date, update_user
FROM gl_accounts
WHERE account = $1 and child = $2
ORDER BY 1,2
LIMIT 10000
`

type GetGLAccountParams struct {
	Account int32 `json:"account"`
	Child   int32 `json:"child"`
}

func (q *Queries) GetGLAccount(ctx context.Context, arg GetGLAccountParams) (GlAccount, error) {
	row := q.db.QueryRow(ctx, getGLAccount, arg.Account, arg.Child)
	var i GlAccount
	err := row.Scan(
		&i.Account,
		&i.Child,
		&i.ParentAccount,
		&i.Type,
		&i.SubType,
		&i.Description,
		&i.Balance,
		&i.Comments,
		&i.CreateDate,
		&i.CreateUser,
		&i.UpdateDate,
		&i.UpdateUser,
	)
	return i, err
}

const listGeneralLedger = `-- name: ListGeneralLedger :many
SELECT account, child, parent_account, type, sub_type, description, balance, comments, create_date, create_user, update_date, update_user from gl_accounts order by 1,2
LIMIT 10000
`

func (q *Queries) ListGeneralLedger(ctx context.Context) ([]GlAccount, error) {
	rows, err := q.db.Query(ctx, listGeneralLedger)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GlAccount{}
	for rows.Next() {
		var i GlAccount
		if err := rows.Scan(
			&i.Account,
			&i.Child,
			&i.ParentAccount,
			&i.Type,
			&i.SubType,
			&i.Description,
			&i.Balance,
			&i.Comments,
			&i.CreateDate,
			&i.CreateUser,
			&i.UpdateDate,
			&i.UpdateUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGLAccount = `-- name: UpdateGLAccount :one
UPDATE gl_accounts set 
account = $1, 
child = $2, 
parent_account = $3, 
type = $4, 
sub_type = $5, 
description = $6, 
balance = $7, 
comments = $8, 
create_date = $9,
create_user = $10, 
update_date = $11,
update_user = $12 where account = $1 and child = $2
RETURNING account, child, parent_account, type, sub_type, description, balance, comments, create_date, create_user, update_date, update_user
`

type UpdateGLAccountParams struct {
	Account       int32          `json:"account"`
	Child         int32          `json:"child"`
	ParentAccount pgtype.Bool    `json:"parent_account"`
	Type          pgtype.Text    `json:"type"`
	SubType       pgtype.Text    `json:"sub_type"`
	Description   pgtype.Text    `json:"description"`
	Balance       pgtype.Numeric `json:"balance"`
	Comments      pgtype.Text    `json:"comments"`
	CreateDate    pgtype.Date    `json:"create_date"`
	CreateUser    pgtype.Text    `json:"create_user"`
	UpdateDate    pgtype.Date    `json:"update_date"`
	UpdateUser    pgtype.Text    `json:"update_user"`
}

func (q *Queries) UpdateGLAccount(ctx context.Context, arg UpdateGLAccountParams) (GlAccount, error) {
	row := q.db.QueryRow(ctx, updateGLAccount,
		arg.Account,
		arg.Child,
		arg.ParentAccount,
		arg.Type,
		arg.SubType,
		arg.Description,
		arg.Balance,
		arg.Comments,
		arg.CreateDate,
		arg.CreateUser,
		arg.UpdateDate,
		arg.UpdateUser,
	)
	var i GlAccount
	err := row.Scan(
		&i.Account,
		&i.Child,
		&i.ParentAccount,
		&i.Type,
		&i.SubType,
		&i.Description,
		&i.Balance,
		&i.Comments,
		&i.CreateDate,
		&i.CreateUser,
		&i.UpdateDate,
		&i.UpdateUser,
	)
	return i, err
}
